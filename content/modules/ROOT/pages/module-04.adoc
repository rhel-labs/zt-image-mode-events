= Making changes to bootc systems

In this lab, you will learn how to make configuration or software changes in images and apply them to bootc hosts. 

[#update-container]
== Changing the bootc image

We've created our first system but there are a few things that might be missing we typically 
do to our systems. Not requiring a password every time we use sudo might be something we allow 
admins to do. We may also need to put notices on logins or present info in the MOTD. Let's make 
some changes to how the system behaves. 


RHEL supports drop-in directories for several services and applications, including 
`sudo` privileges. 

Drop-in support lets us add a file to a `<servicename>.d` directory rather than editing 
the main configuration file. You might already be familiar with drop-in config files from working with Apache and it's `/etc/httpd/conf.d/` directory. Using drop-in files lets us affect the configuration of a system, without needing to edit a file in place, or carry a full configuration file in the image.


Let's address the sudoers password first, by allowing users in the wheel group to not need to enter their password.

[source,bash,role="execute",subs=attributes+]
----
nano 10-wheel
----

Add the following and save the file

[source,shell,role="execute",subs=attributes+]
----
# Enable passwordless sudo for the wheel group
%wheel        ALL=(ALL)       NOPASSWD: ALL
----

For some cloud provider serial consoles we need to update the ttyS0 definition

[source,bash,role="execute",subs=attributes+]
----
nano console_kargs.conf
----

Add the following and save the file

[source,shell,role="execute",subs=attributes+]
----
kargs = ["console=tty0", "console=ttyS0,115200n8"]
----

Now that we have our new configs, we can add them to the end of the Containerfile and rebuild the image.

[source,bash,role="execute",subs=attributes+]
----
nano Containerfile
----

[source,dockerfile,role="execute",subs=attributes+]
----

# Add image controlled configs
COPY 10-wheel /etc/sudoers.d/wheel
COPY console_kargs.conf /usr/lib/bootc/kargs.d/05-cloud-kargs.toml
----


[source,bash,role="execute",subs=attributes+]
----
podman build --file Containerfile --tag registry-{guid}.{domain}/base
----

[#distribute]
== Distributing the bootc image

We used local storage to create our virtual machine image, but to update a running host we need a different way to make images available to running hosts.
Now that we have a full operating system in a standard OCI container image, we can use standard container registries to host and distribute our OS images. 

We have a registry available within the lab environment we can push our image to:

[source,bash,role="execute",subs=attributes+]
----
podman push registry-{guid}.{domain}/base
----
....
Error: trying to reuse blob sha256:7c1862f54f1a8b765bb4f3c6763cfc512d00bfe4fa3246fbcf38c273489a9be1 at destination: checking whether a blob sha256:7c1862f54f1a8b765bb4f3c6763cfc512d00bfe4fa3246fbcf38c273489a9be1 exists in registry-mjghb.apps.ocpvdev01.rhdp.net/base: authentication required
....

It's common for enterprise registries to require some sort of authentication to push or pull images. 
We can log in and cache credentials in our shell, but that won't work for the image mode hosts.

[source,bash,role="execute",subs=attributes+]
----
podman login -u core -p redhat registry-{guid}.{domain}
----

To create system credentials, we'll reuse the user login, but typically some sort of service acccount would be used.
In any case, the files are identeical, and can be published in the image. This will allow a newly created image mode host to update immediately after install.

The credentials are on disk, but the `podman login` command can also generate a file for a single registry. 
This can be useful as users may have personal credentials for a number of different registries and we don't want to accidentally include or leak these into different environments.
[source,bash,role="execute",subs=attributes+]
----
podman login -u core -p redhat registry-{guid}.{domain} --authfile=auth.json
----

With the authfile created, we can add this to the Containerfile.
Since we've made a change to our definition, we need to rebuld the image.
[source,dockerfile,role="execute",subs=attributes+]
----
COPY auth.json /etc/ostree/auth.json
----
[source,bash,role="execute",subs=attributes+]
----
podman build --file Containerfile --tag registry-{guid}.{domain}/base
----

Now we can push our updated image to the registry.
[source,bash,role="execute",subs=attributes+]
----
podman push registry-{guid}.{domain}/base
----

We now have replaced the original image in the registry we used to create the virtual machine with a new image. This is the standard workflow for making changes to an image mode host. All of our updates, additions, or changes are done via the build systems we use, and are then published to be used by the hosts. We'll talk more about updates and how to differentiate them in a later exercise.

[#update-vm]
== Updating the virtual machine

Switch back to the tab labeled Ops VM.

By default, image mode hosts ship with a timer that checks for and applies available updates.
[source,bash,role="execute",subs=attributes+]
----
systemctl list-timers
----

The timer will fire some random interval after boot.
This can be controlled via the Containerfile, we'll take a look at an example of this later.

[source,bash,role="execute",subs=attributes+]
----
systemctl status bootc-fetch-apply-updates.timer
----

Rather than wait for the timer to fire, go ahead and run `bootc update` by hand.
(Reminder, the password for `sudo` is `redhat` as set in the customization blueprint)
[source,bash,role="execute",subs=attributes+]
----
sudo bootc update
----
....
error: Upgrading: Preparing import: Fetching manifest: failed to invoke method OpenImage: reading manifest latest in registry-mjghb.apps.ocpvdev01.rhdp.net/base: authentication required
....

Since we created this VM before we added the credentials to the image, we need to create them manually.
One of the important details of image mode operations is how host filesystems are treated.
The `/etc` directory can be updated either via the image or via the running host.
This allows for central control with local overrides.
During an update, `bootc` will compare the incoming `/etc` to the host `/etc` to determine what changes to make.
If there have been local updates, those will be preserved, otherwise the new file will be installed.
We've written more about this https://developers.redhat.com/articles/2025/08/25/what-image-mode-3-way-merge['3 way merge' process ,window=_blank] and the implications for image mode hosts.
[source,bash,role="execute",subs=attributes+]
----
sudo podman login -u core -p redhat registry-{guid}.{domain} --authfile=/etc/ostree/auth.json
----

[source,dockerfile,role="execute",subs=attributes+]
----
ls /etc/ostree/auth.json
----

With the system credentials in place, try the update again.
(Reminder, the password for `sudo` is `redhat`)
[source,bash,role="execute",subs=attributes+]
----
sudo bootc update
----

Notice that `bootc update` provides information about the layers that have been modified and a progress indicator. The update mechanism also uses container tools to pull the image from the registry to the host for preparation. This means we only pull down the layers that were changed, not the full image if not needed. Later versions of `bootc` will expand this idea of delta updated to further reduce the time and bandwidth used for updates.

The final output should look something like this:
....
layers already present: 0; layers needed: 72 (1.1 GB)
Fetched layers: 1.05 GiB in 25 seconds (43.11 MiB/s)                            
    Deploying: done (11 seconds)
Queued for next boot: registry-mjghb.apps.ocpvdev01.rhdp.net/base
    Version: 10.1
    Digest: sha256:10eb5e2ebba0e549deb43315786731ff976d544f6f682c4cf30de0f4c371a059
Total new layers: 72    Size: 1.1 GB
Removed layers:   69    Size: 2.1 GB
Added layers:     72    Size: 1.1 GB
....
NOTE: At the time of writing, the first update of an image mode host may be larger than just the layers changed at build time. This is due to registry versus local storage when the disk image was created.

Let's check the current status of the host.
[source,bash,role="execute",subs=attributes+]
----
sudo bootc status
----
....
 Staged image: registry-mjghb.apps.ocpvdev01.rhdp.net/base
        Digest: sha256:10eb5e2ebba0e549deb43315786731ff976d544f6f682c4cf30de0f4c371a059 (amd64)
       Version: 10.1 (2025-11-13T17:17:56Z)

● Booted image: registry-mjghb.apps.ocpvdev01.rhdp.net/base
        Digest: sha256:b937c4633ae298d3c68d97810b1b6dc276e8d47f8aea0a6ba85eff540b966539 (amd64)
       Version: 10.1 (2025-11-13T16:56:36Z)
....

Updates to bootc hosts are offline in nature, meaning the new image has been readied for deployment, but no other changes have been made to the running system. 

The last step for the change to take is to reboot the virtual machine. Before doing so, please make sure you are logged in to the virtual machine and not the hypervisor, the prompt should look like `[{vm_user}@localhost ~]$`.

[source,bash,role="execute",subs=attributes+]
----
sudo systemctl reboot
----

[#testing]
== Testing the changes
Log back into the VM by clicking `reconnect` and look for the kernel arguments we added via the `bootc` configuration path.
[source,bash,role="execute",subs=attributes+]
----
cat /proc/cmdline
----

The status now shows a rollback image instead of a staged image. 
We'll explore what that means in a later exercise.
[source,bash,role="execute",subs=attributes+]
----
sudo bootc status
----
....
● Booted image: registry-bkg5j.apps.ocpvdev01.rhdp.net/base
        Digest: sha256:2b61cd3814d2ec1a0a420435fe7c2fef0423d40b3ce1859cc5b14e1393ef3672 (amd64)
       Version: 10.1 (2025-11-26T22:22:04Z)

  Rollback image: registry-bkg5j.apps.ocpvdev01.rhdp.net/base
          Digest: sha256:e4688ba584b714092e50493ee3ae10249fc506e68b404bd4095f0d6911124de1 (amd64)
         Version: 10.1 (2025-11-26T21:54:28Z)
....
