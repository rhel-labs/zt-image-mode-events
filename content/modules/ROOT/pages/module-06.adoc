= Security and Compliance in an Image Mode world.

Building and Deploying using Image Mode has some built-in benefits from a security and compliance perspective.  First, systems deployed with Image Mode are more likely to be built to your desired specifications, and second it is much easier to make sure that they stay that way.  In the next few modules we'll walk through how to add security and compliance into your build, and also how to apply that policy using automation.  We will also touch a bit on drift and getting your systems back into compliance after an event.

== Building a new VM
Because in this section we will be making significant changes to our system, we are going to start fresh.  First we will build an updated bootc image, and then we will build a new guest vm just like we did at the beginning of the lab.

== Adding a security control to your image FAPolicyd

A common service that helps you meet your security and compliance mandates, is FAPolicyd.  The File Access Policy Daemon is a service that implements application allow-listing.  So let's see what it looks like to simply add it to our `Containerfile`.  

** _NOTE_: We will be adding these changes after the Maintainer metadata line that was added earlier in our Containerfile so, after the "LABEL vendor="Example Corp" line, we'll add the following

[source,bash,role="execute",subs=attributes+]
----
# Security and Hardening 

RUN dnf -y install audit fapolicyd openscap-utils scap-security-guide setroubleshoot-server

RUN systemctl enable fapolicyd
----

We are adding more than just FAPolicyd in that dnf install, we will be using those other packages later.

== Build and Push

Now, if we build the image and push it, we can deploy and see if FAPolicyD is working.

[source,bash,role="execute",subs=attributes+]
----
podman build --file Containerfile --tag registry-{guid}.{domain}/base
----
[source,bash,role="execute",subs=attributes+]
----
podman push registry-{guid}.{domain}/base
----

Now, we can build a new disk image, and start our new VM. 

[source,bash,role="execute",subs=attributes+]
----
sudo podman run --rm --privileged --security-opt label=type:unconfined_t   --volume ./config.toml:/config.toml   --volume /var/lib/containers/storage:/var/lib/containers/storage   --volume .:/output   registry.redhat.io/rhel10/bootc-image-builder:10.1   --type qcow2   registry-xxt88.apps.ocpvdev01.rhdp.net/base
----

Now let's copy that disk image to the proper location.  
[source,bash,role="execute",subs=attributes+]
----
cp -f qcow2/disk.qcow2 /var/lib/libvirt/images/security-vm.qcow2
----

Noiw we can build that into a new VM.

[source,bash,role="execute",subs=attributes+]
----
virt-install --name security-vm \
  --disk /var/lib/libvirt/images/security-vm.qcow2 \
  --import \
  --memory 4096 \
  --graphics none \
  --osinfo rhel10-unknown \
  --noautoconsole \
  --noreboot
----

After that completes, you will find the new system in the Security VM tab.

## Testing FAPolicyd
Our goal here was to deploy fapolicyd, so now that we have, let's see if its working. 

The File Access Policy daemon's job is to prevent you from running unapproved applications.  Out of the box, it does this using a relatively simple application allow-list that has known trusted paths for installed binaries.  

To test whether it's working, we can just take a known good binary, and put it somewhere odd, and then try to run it. 

[source,bash,role="execute",subs=attributes+]
----
cp /bin/ls ~
----

[source,bash,role="execute",subs=attributes+]
----
~/ls
----

You should not be allowed to run ls from your home directorn. 
....
$ ~/ls 
-bash: /home/rhel/ls: Operation not permitted
....

Great! FAPolicyd works!  But, we're nowhere close to being compliant with a security policy, for that we'll need to do more than just install a service and enable it.  For that, we'll want to deploy a full policy.  You guessed it, in our next module we'll do just that! 
